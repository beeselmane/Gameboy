#import "GBGameboyInstance.h"
#import "gameboy.h"

#define kGBTileCount            384
#define kGBTileHeight           8
#define kGBTileWidth            8

#define kGBTilesetOffset        0
#define kGBBackground0Offset    0x1C00
#define kGBBackground1Offset    0x1800

#define kGBBackgroundTileCount  32

__attribute__((section("__TEXT,__rom"))) UInt8 gGBDMGOriginalROM[0x100] = {
    0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
    0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
    0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
    0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
    0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
    0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
    0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
    0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
    0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xE2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
    0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
    0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
    0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
    0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
    0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3C, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x3C,
    0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
    0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50
};

__attribute__((section("__TEXT,__rom"))) UInt8 gGBDMGEditedROM[0x100] = {
    0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
    0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
    0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
    0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
    0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
    0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
    0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
    0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
    0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xE2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
    0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
    0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
    0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
    0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
    0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3C, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x3C,
    0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x00, 0x00, 0x23, 0x7D, 0xFE, 0x34, 0x20,
    0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x00, 0x00, 0x3E, 0x01, 0xE0, 0x50
};

@interface GBGameboyInstance ()

- (NSBitmapImageRep *) makeBitmapImageOfWidth:(UInt32)width height:(UInt32) height;

- (NSImage *) decodeTileset:(UInt8 *)source into:(UInt32 [kGBTileCount][kGBTileWidth * kGBTileHeight])result needsImage:(bool)needsImage;
- (void) decodeTile:(UInt8 *)tileSource into:(UInt32 [kGBTileWidth * kGBTileHeight])result;

@end

@implementation GBGameboyInstance

@dynamic screen;

- (instancetype) init
{
    self = [super init];

    if (self)
    {
        self->gameboy = GBGameboyCreate();
        NSAssert(self->gameboy, @"Error: Could not instantiate gameboy instance!");

        GBBIOSROM *bios = GBBIOSROMCreate(gGBDMGEditedROM);
        NSAssert(self->gameboy, @"Error: Could not instantiate gameboy ROM!");

        GBGameboyInstallBIOS(self->gameboy, bios);
        GBGameboyPowerOn(self->gameboy);

        _cartInstalled = false;
    }

    return self;
}

- (void) installCartFromFile:(NSString *)path
{
    return [self installCartFromData:[[NSFileManager defaultManager] contentsAtPath:path]];
}

- (void) installCartFromData:(NSData *)data
{
    GBCartridge *cart = GBCartridgeCreate((UInt8 *)[data bytes], (UInt32)[data length]);

    if (!cart)
        return;

    bool inserted = GBCartridgeInsert(cart, self->gameboy);

    if (!inserted)
        return;

    _cartInstalled = YES;
}

- (UInt32 *) screen
{
    return self->gameboy->driver->screenData;
}

- (void) tick:(NSUInteger)times
{
    for (NSUInteger i = 0; i < times; i++)
        GBClockTick(self->gameboy->clock);

    /*if (times & 1) {
     for (UInt32 i = 0; i < kGBScreenHeight * kGBScreenWidth; i++)
     self->gameboy->driver->screenData[i] = 0xFF229922;
     } else {
     for (UInt32 i = 0; i < kGBScreenHeight * kGBScreenWidth; i++)
     self->gameboy->driver->screenData[i] = 0xFF992299;
     }*/
}

#pragma mark - Background/Palette Image Routines

- (NSBitmapImageRep *) makeBitmapImageOfWidth:(UInt32)width height:(UInt32) height
{
    NSBitmapImageRep *bitmapImage = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:nil
                                                                            pixelsWide:width
                                                                            pixelsHigh:height
                                                                         bitsPerSample:8
                                                                       samplesPerPixel:3
                                                                              hasAlpha:NO
                                                                              isPlanar:NO
                                                                        colorSpaceName:NSCalibratedRGBColorSpace
                                                                           bytesPerRow:(width * 4)
                                                                          bitsPerPixel:32];
    return bitmapImage;
}

- (void) decodeTile:(UInt8 *)tileSource into:(UInt32 [kGBTileWidth * kGBTileHeight])result
{
    UInt32 lookup[4] = {0xEEEEEE, 0x000000, 0x555555, 0xBBBBBB};

    for (UInt8 y = 0; y < (2 * kGBTileHeight); y += 2)
    {
        for (UInt8 x = 0; x < kGBTileWidth; x++)
        {
            UInt8 value = ((tileSource[y + 1] >> x) << 1) & 2;
            value |= (tileSource[y] >> x) & 1;

            result[(y * 4) + (7 - x)] = lookup[value];
        }
    }
}

- (NSBitmapImageRep *) decodeTileset:(UInt8 *)source into:(UInt32 [kGBTileCount][kGBTileWidth * kGBTileHeight])result needsImage:(bool)needsImage
{
     NSBitmapImageRep *image = [self makeBitmapImageOfWidth:128 height:192];

     for (UInt16 i = 0; i < kGBTileCount; i++)
     {
         [self decodeTile:&source[i * (2 * kGBTileHeight)] into:result[i]];

         if (needsImage)
         {
             UInt16 y = i / (2 * kGBTileHeight);
             UInt16 x = i % (2 * kGBTileWidth);

             for (UInt8 y0 = 0; y0 < kGBTileHeight; y0++)
             {
                 for (UInt8 x0 = 0; x0 < kGBTileWidth; x0++)
                 {
                     NSUInteger color = result[i][(y0 * kGBTileHeight) + x0];

                     NSUInteger rgb[3] = {
                         (color >> 16) & 0xFF,
                         (color >>  8) & 0xFF,
                         (color >>  0) & 0xFF
                     };

                     [image setPixel:rgb atX:((x * kGBTileWidth) + x0) y:((y * kGBTileHeight) + y0)];
                 }
             }
         }
     }

    return image;
}

- (NSImage *) tileset
{
    UInt32 tiles[kGBTileCount][kGBTileWidth * kGBTileHeight];
    UInt8 *tileset = &gameboy->vram->memory[0];

    return [self decodeTileset:tileset into:tiles needsImage:YES];
}

- (NSImage *) generateBitmap:(UInt8)map isHighMap:(bool)isHighMap
{
    bool isFirstMap = !map;

    UInt8 *sourceData = &gameboy->vram->memory[isFirstMap ? kGBBackground0Offset : kGBBackground1Offset];
    UInt8 *tileset = &gameboy->vram->memory[0];

    UInt32 tiles[kGBTileCount][kGBTileWidth * kGBTileHeight];
    [self decodeTileset:tileset into:tiles needsImage:NO];

    NSBitmapImageRep *image = [self makeBitmapImageOfWidth:(kGBBackgroundTileCount * kGBTileWidth) height:(kGBBackgroundTileCount * kGBTileHeight)];

    for (UInt8 y = 0; y < kGBBackgroundTileCount; y++)
    {
        for (UInt8 x = 0; x < kGBBackgroundTileCount; x++)
        {
            UInt8 tile;

            if (isHighMap) {
                SInt8 tid = (y * kGBBackgroundTileCount) + x;

                // -128 ---  0  --- +127
                //   0  --- 128 ---  255
                tile = sourceData[tid + 128];
            } else {
                tile = sourceData[(y * kGBBackgroundTileCount) + x];
            }


            for (UInt8 y0 = 0; y0 < kGBTileHeight; y0++)
            {
                for (UInt8 x0 = 0; x0 < kGBTileWidth; x0++)
                {
                    NSUInteger color = tiles[tile][(y0 * kGBTileHeight) + x0];

                    NSUInteger rgb[3] = {
                        (color >> 16) & 0xFF,
                        (color >>  8) & 0xFF,
                        (color >>  0) & 0xFF
                    };

                    [image setPixel:rgb atX:((x * kGBTileWidth) + x0) y:((y * kGBTileHeight) + y0)];
                }

            }
        }
    }

    return [[NSImage alloc] initWithCGImage:[image CGImage] size:NSMakeSize((kGBBackgroundTileCount * kGBTileWidth), (kGBBackgroundTileCount * kGBTileHeight))];
}

#if 0

    UInt8 control = gameboy->mmio->portMap[0x40]->value;
    bool highmap = control & 0x10;

    //UInt32 map1data[32 * 32 * 8 * 8];
    //UInt32 map0data[32 * 32 * 8 * 8];

#endif

@end
